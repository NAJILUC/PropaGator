#!/usr/bin/env python
PACKAGE = "z_drive"
from math import *
from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

#gen.add takes the folowing:
#name - a string which specifies the name under which this parameter should be stored. NOTE: the name can't be "i" "state" or "name"
#type - defines the type of value stored, and can be any of int_t, double_t, str_t, or bool_t
#level - A bitmask which will later be passed to the dynamic reconfigure callback. When the callback is called all of the level values for parameters that have been changed are OR(ed) together and the resulting value is passed to the callback.
#			driver_base/SensorLevels.msg defines the levels (0=running,1=stopped,3=closed) see: http://goo.gl/JdzhVp
#description - string which describes the parameter
#default - specifies the default value
#min - specifies the min value (optional and does not apply to strings and bools)
#max - specifies the max value (optional and does not apply to strings and bools)

control_enum = gen.enum([ gen.const("xbox_analog_only", int_t, 0, "XBOX Analog Sticks Only"),
					gen.const("xbox_analog_to_required", int_t, 1, "XBOX Analog Sticks map to Required Force"),
					gen.const("waypoint_driving", int_t, 2, "Waypoint Driving"),
					gen.const("manual_mode", int_t, 3, "Drive based on manually configured setting below"),
					gen.const("mirror_mode", int_t, 4, "The thrusters and servors mirror each other and do the same thing"),
					gen.const("extra5", int_t, 5, "undefined mode extra5"),
					gen.const("testing_mode", int_t, 6, "A random mode that is used for testing things") ],
					"An enum of the controller Type that should be used to drive the boat")

gen.add("control_method", int_t, 0, "Control Method to drive the boat", 0, 0, 6, edit_method=control_enum)

gen.add("update_rate", double_t, 0, "The rate in Hz that the processes callbacks", 50, 0, 100)

boat_mass = 36.2874
boat_inertia = 7.4623
gen.add("boat_mass", double_t, 0, "The mass of the boat in Kg", boat_mass, 0, 100)
gen.add("boat_inertia", double_t, 0, "Inertia of the boat in (m^2)/kg", boat_inertia, 0, 10)

#port servo offsets remember according to ros rep 103: x=forward, y=left,	z=up
#port_servo is back .7239m, left of centerline .3048m, 0m above the water
gen.add("port_servo_x_offset", double_t, 0, "", -.7239, -1, 1)
gen.add("port_servo_y_offset", double_t, 0, "", .3048, -1, 1)
gen.add("port_servo_z_offset", double_t, 0, "", 0, -1, 1)
#starboard_servo is back .7239m, right of center line .3048m, 0m above the water
gen.add("starboard_servo_x_offset", double_t, 0, "", -.7239, -1, 1)
gen.add("starboard_servo_y_offset", double_t, 0, "", -.3048, -1, 1)
gen.add("starboard_servo_z_offset", double_t, 0, "", 0, -1, 1)

# These are the tunable gain parameters for the "pd" controller.
p_gain_x=50.0;
p_gain_y=50.0;
p_gain_theta_boat=1.0;
gen.add("p_gain_x", double_t, 0, "", p_gain_x, 0, 1000)
gen.add("d_gain_x", double_t, 0, "", sqrt(4*p_gain_x*boat_mass), 0, 1000)
gen.add("p_gain_y", double_t, 0, "", p_gain_y, 0, 1000)
gen.add("d_gain_y", double_t, 0, "", sqrt(4*p_gain_y*boat_mass), 0, 1000)
gen.add("p_gain_theta_boat", double_t, 0, "", p_gain_theta_boat, 0, 1000)
gen.add("d_gain_theta_boat", double_t, 0, "", sqrt(4*p_gain_theta_boat*boat_inertia), 0, 1000)

# these are gains for the cost function
gen.add("gain_error_force_x", double_t, 0, "", 100, 0, 1000)
gen.add("gain_error_force_y", double_t, 0, "", 1000, 0, 1000)
gen.add("gain_error_moment_z", double_t, 0, "", 1000, 0, 1000)
gen.add("gain_thrusters_force", double_t, 0, "", 10, 0, 1000)
gen.add("gain_deviation_equilibrum_servo_angle", double_t, 0, "", 0, 0, 1)
gen.add("gain_deviation_changeof_servo_angle", double_t, 0, "", .01, 0, 1)

gen.add("step_size", double_t, 0, "", 100, 0, 1000)
gen.add("step_multiplier", double_t, 0, "", 100, 0, 1000)

gen.add("cost_count_max", double_t, 0, "", 100, 0, 1000)


#thruster_limit=80.0679891
thruster_limit=100
gen.add("port_servo_angle_offset", double_t, 0, "", pi, 0, 2*pi)
gen.add("port_servo_angle_clock_wise_limit", double_t, 0, "", (-70*pi)/180, -pi, pi)
gen.add("port_servo_angle_counter_clock_wise_limit", double_t, 0, "", (100*pi)/180, -pi, pi)
gen.add("port_thruster_foward_limit", double_t, 0, "", thruster_limit, -100, 100)
#gen.add("port_thruster_reverse_limit", double_t, 0, "", -.8*thruster_limit, -100, 100)
gen.add("port_thruster_reverse_limit", double_t, 0, "", -thruster_limit, -100, 100)
gen.add("starboard_servo_angle_offset", double_t, 0, "", pi, 0, 2*pi)
gen.add("starboard_servo_angle_clock_wise_limit", double_t, 0, "", (-100*pi)/180, -pi, pi)
gen.add("starboard_servo_angle_counter_clock_wise_limit", double_t, 0, "", (70*pi)/180, -pi, pi)
gen.add("starboard_thruster_foward_limit", double_t, 0, "", thruster_limit, -100, 100)
#gen.add("starboard_thruster_reverse_limit", double_t, 0, "", -.8*thruster_limit, -100, 100)
gen.add("starboard_thruster_reverse_limit", double_t, 0, "", -thruster_limit, -100, 100)

gen.add("manual_port_servo_angle",int_t, 0, "", 0, -180, 180)
gen.add("manual_port_thruster_force", int_t, 0, "", 0, -100, 100)
gen.add("manual_starboard_servo_angle",int_t, 0, "", 0, -180, 180)
gen.add("manual_starboard_thruster_force", int_t, 0, "", 0, -100, 100)


#tell the generator to generate the necessary files and exit the program.
#The second parameter is the name of a node this could run in (used to generate documentation only), the third parameter is a name prefix the generated files will get (e.g. "<name>Config.h" for c++, or "<name>Config.py" for python.)
# NOTE: The third parameter should be equal to the cfg file name, without extension. Otherwise the libraries will be generated in every build, forcing a recompilation of the nodes which use them.
exit(gen.generate(PACKAGE, "z_drive", "Gains"))

# NOTE: be sure to make this cfg file executable with: chmod a+x cfg/Gains.cfg